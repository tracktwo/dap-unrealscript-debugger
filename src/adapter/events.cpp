
#include "client.h"
#include "debugger.h"
#include "adapter.h"

using namespace unreal_debugger::events;

void show_dll_form(const ShowDllForm& ev)
{
    // Tell the debugger we've hit a breakpoint.
    breakpoint_hit();
}

void build_hierarchy(const BuildHierarchy& ev)
{

}

void clear_hierarchy(const ClearHierarchy& ev)
{

}

void add_class_to_hierarchy(const AddClassToHierarchy& ev)
{

}

void clear_a_watch(const ClearAWatch& ev)
{
    debugger.clear_watch(static_cast<Debugger::WatchKind>(ev.watch_type()));
}

void add_a_watch(const AddAWatch& ev)
{
    debugger.add_watch(static_cast<Debugger::WatchKind>(ev.watch_type()), ev.assigned_index(), ev.parent_index(), ev.name(), ev.value());
}

void lock_list(const LockList& ev)
{

}

void unlock_list(const UnlockList& ev)
{

}

void add_breakpoint(const AddBreakpoint& ev)
{

}

void remove_breakpoint(const RemoveBreakpoint& ev)
{

}

void editor_load_class(const EditorLoadClass& ev)
{
    debugger.load_class(ev.class_name());
}

void editor_goto_line(const EditorGotoLine& ev)
{
    debugger.goto_line(ev.line_number());
}

void add_line_to_log(const AddLineToLog& ev)
{
    console_message(ev.text());
}

void call_stack_clear(const CallStackClear& ev)
{
    debugger.clear_callstack();
}

void call_stack_add(const CallStackAdd& ev)
{
    debugger.add_callstack(ev.entry());
}

void set_current_object_name(const SetCurrentObjectName& ev)
{

}

void set_terminated(const Terminated& ev)
{
    debugger_terminated();
}

// Helper for event dispatch checking.
//
// Given an event, a predicate, a getter, and a handler, if the predicate on the event is
// true, invoke the handler passing the result of the getter. Otherwise, emit an error.
//
// This is intended for use when we have an event with some kind field set and need to verify
// that the payload matches that kind and invoke the correct handler with that payload.
// The predicate is the 'has_foo' function generated by protobuf to test if the oneof field
// is set, and the getter is the corresponding 'foo' function that retreives a reference to
// the payload object. The handler accepts a const reference to the payload and does the
// actual work. If the payload does not match this indicates a bug in the interface: it sent us
// an event without the correct payload member set.
template <typename Pred, typename Getter, typename Handler>
void dispatch_event(const Event& ev, Pred predicate, Getter getter, Handler handler)
{
    if ((ev.*predicate)())
    {
        handler((ev.*getter)());
    }
    else
    {
        dap::writef(log_file, "Error: event %s has mismatched payload\n", ev.Kind_Name(ev.kind()).c_str());
    }
}

void dispatch_event(const Event& ev)
{
    switch (ev.kind())
    {
    case Event_Kind_ShowDllForm:            dispatch_event(ev, &Event::has_show_dll_form,           &Event::show_dll_form,              &show_dll_form);            break;
    case Event_Kind_BuildHierarchy:         dispatch_event(ev, &Event::has_build_hierarchy,         &Event::build_hierarchy,            &build_hierarchy);          break;
    case Event_Kind_ClearHierarchy:         dispatch_event(ev, &Event::has_clear_hierarchy,         &Event::clear_hierarchy,            &clear_hierarchy);          break;
    case Event_Kind_AddClassToHierarchy:    dispatch_event(ev, &Event::has_add_class_to_hierarchy,  &Event::add_class_to_hierarchy,     &add_class_to_hierarchy);   break;
    case Event_Kind_ClearAWatch:            dispatch_event(ev, &Event::has_clear_a_watch,           &Event::clear_a_watch,              &clear_a_watch);            break;
    case Event_Kind_AddAWatch:              dispatch_event(ev, &Event::has_add_a_watch,             &Event::add_a_watch,                &add_a_watch);              break;
    case Event_Kind_LockList:               dispatch_event(ev, &Event::has_lock_list,               &Event::lock_list,                  &lock_list);                break;
    case Event_Kind_UnlockList:             dispatch_event(ev, &Event::has_unlock_list,             &Event::unlock_list,                &unlock_list);              break;
    case Event_Kind_AddBreakpoint:          dispatch_event(ev, &Event::has_add_breakpoint,          &Event::add_breakpoint,             &add_breakpoint);           break;
    case Event_Kind_RemoveBreakpoint:       dispatch_event(ev, &Event::has_remove_breakpoint,       &Event::remove_breakpoint,          &remove_breakpoint);        break;
    case Event_Kind_EditorLoadClass:        dispatch_event(ev, &Event::has_editor_load_class,       &Event::editor_load_class,          &editor_load_class);        break;
    case Event_Kind_EditorGotoLine:         dispatch_event(ev, &Event::has_editor_goto_line,        &Event::editor_goto_line,           &editor_goto_line);         break;
    case Event_Kind_AddLineToLog:           dispatch_event(ev, &Event::has_add_line_to_log,         &Event::add_line_to_log,            &add_line_to_log);          break;
    case Event_Kind_CallStackClear:         dispatch_event(ev, &Event::has_call_stack_clear,        &Event::call_stack_clear,           &call_stack_clear);         break;
    case Event_Kind_CallStackAdd:           dispatch_event(ev, &Event::has_call_stack_add,          &Event::call_stack_add,             &call_stack_add);           break;
    case Event_Kind_SetCurrentObjectName:   dispatch_event(ev, &Event::has_set_current_object_name, &Event::set_current_object_name,    &set_current_object_name);  break;
    case Event_Kind_Terminated:             dispatch_event(ev, &Event::has_terminated,              &Event::terminated,                 &set_terminated);           break;
    default:
        dap::writef(log_file, "Error: got unknown event %d\n", ev.kind());
    }
}
